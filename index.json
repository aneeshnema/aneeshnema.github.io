[{"content":" The associative container lookup functions (find, lower_bound, upper_bound, equal_range) only take an argument of key_type, requiring users to construct (either implicitly or explicitly) an object of the key_type to do the lookup. This may be expensive, e.g. constructing a large object to search in a set when the comparator function only looks at one field of the object. There is strong desire among users to be able to search using other types which are comparable with the key_type.\n Consider the below structure Book\nstruct Book { std::string title; Book(const std::string \u0026amp;str):title(str){} }; Now, suppose we are making a library that will store our books in std::set, and to compare books we will use the title of Book.\nint main() { std::set\u0026lt;Book\u0026gt; library; library.insert(Book(\u0026#34;The Alchemist\u0026#34;)); auto search = library.find(\u0026#34;The Alchemist\u0026#34;); std::cout \u0026lt;\u0026lt; (search != library.end()? \u0026#34;Found\u0026#34;:\u0026#34;Not Found\u0026#34;) \u0026lt;\u0026lt; std::endl; } ‚ùå Error:  no matching function for call to ‚Äòstd::set\u0026lt;Book\u0026gt;::find(const char [5])‚Äô\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; 17 |\u0026nbsp; \u0026nbsp; auto search = library.find(\"The Alchemist\");  This does not work because library.find expects us to pass a Book object instead of string.\nTo overcome this, we can do library.find(Book(\u0026quot;The Alchemist\u0026quot;)); instead, but this creates a temporary object which is passed to the .find function.\nTo avoid creating temporary objects, we can create a transparent functor (comparator class) by defining is_transparent inside the functor.\n A \u0026ldquo;transparent functor\u0026rdquo; is one which accepts any argument types (which don\u0026rsquo;t have to be the same) and simply forwards those arguments to another operator.\n struct Compare { using is_transparent = void; bool operator()(const Book \u0026amp;lhs, const Book \u0026amp;rhs) const { return lhs.title \u0026lt; rhs.title; } bool operator()(const Book \u0026amp;lhs, const std::string \u0026amp;rhs) const { return lhs.title \u0026lt; rhs; } bool operator()(const std::string \u0026amp;lhs, const Book \u0026amp;rhs) const { return lhs \u0026lt; rhs.title; } }; int main() { std::set\u0026lt;Book, Compare\u0026gt; library; library.insert(Book(\u0026#34;The Alchemist\u0026#34;)); auto search = library.find(\u0026#34;The Alchemist\u0026#34;); std::cout \u0026lt;\u0026lt; (search != library.end()? \u0026#34;Found\u0026#34;:\u0026#34;Not Found\u0026#34;) \u0026lt;\u0026lt; std::endl; } Found Although the above code works, there is still a hidden temporary object being created, i.e., char* \u0026quot;The Alchemist\u0026quot; to std::string on calling library.find(\u0026quot;The Alchemist\u0026quot;);. To solve this problem, we can overload the operator() to accept char*. A more elegant solution would be to use template.\nHere\u0026rsquo;s the final code\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;set\u0026gt; struct Book { std::string title; Book(const std::string \u0026amp;str):title(str){} }; struct Compare { using is_transparent = void; bool operator()(const Book \u0026amp;lhs, const Book \u0026amp;rhs) const { return lhs.title \u0026lt; rhs.title; } template\u0026lt;typename T\u0026gt; bool operator()(const Book \u0026amp;lhs, const T \u0026amp;rhs) const { return lhs.title \u0026lt; rhs; } template\u0026lt;typename T\u0026gt; bool operator()(const T \u0026amp;lhs, const Book \u0026amp;rhs) const { return lhs \u0026lt; rhs.title; } }; int main() { std::set\u0026lt;Book, Compare\u0026gt; library; library.insert(Book(\u0026#34;Ross\u0026#34;)); auto search = library.find(\u0026#34;Ross\u0026#34;); std::cout \u0026lt;\u0026lt; (search != library.end()? \u0026#34;Found\u0026#34;:\u0026#34;Not Found\u0026#34;) \u0026lt;\u0026lt; std::endl; } Now we can use char*, char[], std::string, std::string_view or any other object that can be compared with std::string for comparison.\n‚ÑπÔ∏è Note:  is_transparent was introduced in C++14, make sure to use C++14 or later while compiling  Additional Resources  C\u0026#43;\u0026#43; Proposal N3465  StackOverflow Question  Jason Turner\u0026amp;rsquo;s YouTube video on transparent comparators (recommended)   ","permalink":"https://aneeshnema.github.io/posts/transparent-comparators/","summary":"A brief guide to transparent comparators in C++","title":"Transparent Comparators C++"},{"content":"Under Construction üöß\n","permalink":"https://aneeshnema.github.io/about/","summary":"Under Construction üöß","title":""},{"content":"","permalink":"https://aneeshnema.github.io/search/","summary":"search","title":"Search"}]